# Guided Manual Review Checklist

This checklist helps reviewers validate renamed identifiers and opcode mappings produced by the automated pipeline. Complete the steps in order and record any discrepancies for follow-up.

## 1. Gather context and artefacts
- Open `SUMMARY.md` and `PIPELINE.md` to review the overall reconstruction summary and pipeline stages.
- Load `mapping.lock` (or `mapping.json` if the lock file has not been created yet) to inspect the current rename plan.
- Review opcode documentation in `upcodes.md`, `upcodes.json`, and `upcodes.html` for semantic guesses and helper links.
- Locate the latest run manifest in `run_manifest.json` to confirm the git revision, transforms attempted, and key-handling metadata.

## 2. Validate renamed functions
- Open `deobfuscated_pretty.lua` alongside the original `reconstructed.lua` (or fragments listed in `reconstructed.lua.fragments.json`).
- For each entry in `mapping.lock`, jump to the original identifier using the VS Code reverse-mapping helper in `tools/vscode-reverse-mapping/` or by searching the raw reconstructed source.
- Confirm that docstrings or comment headers above the renamed function (propagated by the pretty-printer) describe its behaviour accurately.
- Run focused parity checks when available:
  - `pytest tests/test_versions.py::test_round_trip_harness_stubbed_success`
  - `pytest tests/test_versions.py::test_pretty_print_with_mapping_updates_comment_headers_and_preview`
- If a rename looks incorrect, note the identifier, file path, and expected behaviour for follow-up.

## 3. Review helper tables and modules
- Inspect lifted helper modules under `out/modules/` (or the helper-table manifest generated by `divide_unit_of_work`).
- Ensure exported helper names match their runtime usage patterns documented in `opcode_guesses.json` and `helpers_to_opcodes.json`.
- When ambiguity remains, execute sandboxed snippets via `python -m src.main sandbox --script-key` to confirm runtime behaviour using the session key streamed through stdin (keys should never be saved to disk).

## 4. Validate opcode mappings
- Cross-reference each opcode entry in `upcodes.md` with its corresponding IR node in `out/ir/` (or `VMIRNode` dumps from `lift_vm`).
- Use the CLI helper `python -m src.main name-opcode <opcode>` in dry-run mode to view current context without writing changes: `python -m src.main name-opcode --dry-run <opcode>`.
- Re-run parity checks targeting VM pipelines:
  - `pytest tests/test_key_usage_scanner.py::test_exact_upcode_parity_success`
  - `pytest tests/test_key_usage_scanner.py::test_discover_transform_order_basic`
- Flag any opcode still marked as `UNKNOWN` in `upcodes.json` and suggest next analysis steps (e.g., fuzzing via `python -m src.main fuzz --script-key`).

## 5. Confirm completeness and safety gates
- Execute `python -m src.main checklist --require-quality-gate --script-key` (provide the session key via stdin) to recompute completeness metrics and verify parity requirements pass.
- Inspect `dangerous_calls.txt` and `reconstructed.license_audit.txt` inside the latest `evidence.zip` bundle to ensure no unsafe runtime calls or licensing issues were introduced during renaming.
- Review `confidence_history.json` to see whether opcode confidence is trending upward; investigate any regressions.

## 6. Document findings and next actions
- Update `STATUS.md` or the relevant tracking document with checklist results, noted issues, and recommended next steps.
- If manual adjustments were made, regenerate pretty-printed output (`python -m src.main pretty-print --script-key`) and rerun the quality gate to confirm a green state before merging changes.

> **Reminder:** Keys must only be provided at runtime via stdin or environment variables and must never be written to disk, committed, or persisted between sessions.
