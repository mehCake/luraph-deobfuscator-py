# Deobfuscation Pipeline

This document is auto-generated by ``version_detector.generate_pipeline_documentation`` to summarise the static and analysis pipeline used by the tooling.

## Stage overview

| Stage | Function | Summary |
| --- | --- | --- |
| 1. Fragment discovery | `extract_fragments` | Scans Lua sources for quoted and bracketed fragments while preserving source offsets for downstream reconstruction. |
| 2. Literal decoding | `_iter_decoded_fragments / lu_unescape` | Normalises escape sequences, canonicalising Lua short-string bodies into decoded text for reconstruction. |
| 3. Escape verification | `_verify_decoded_string_roundtrip` | Ensures decoded literals survive a canonicalise → unescape → escape round-trip so no bytes are lost during reconstruction. |
| 4. Bracket normalisation | `_normalize_long_bracket_literals` | Aligns Lua long-bracket delimiters to a canonical depth while tracking nesting statistics for audits. |
| 5. Whitespace canonicalisation | `_normalize_whitespace` | Collapses inconsistent indentation and spacing while preserving semantic boundaries for subsequent tooling. |
| 6. Numeric literal mapping | `_replace_numeric_literals` | Converts hexadecimal/binary numerics into decimal for readability and records a reversible mapping file. |
| 7. Boundary diffing | `_compute_boundary_report / _summarise_boundary_diff` | Compares reconstructed fragment boundaries against originals to ensure ordering and offsets remain stable. |
| 8. Bytecode detection | `detect_embedded_bytecode` | Scans decoded fragments for Lua bytecode signatures and emits disassembly reports for embedded chunks. |
| 9. Obfuscator fingerprinting | `fingerprint_obfuscation_patterns` | Records stable pattern fingerprints for Luraph v14 payloads so subsequent runs can short-circuit analysis. |
| 10. Function boundary export | `split_functions_from_payload` | Splits the reconstructed payload into per-function files with metadata for manual review. |
| 11. Metadata & provenance extraction | `extract_metadata_provenance` | Pulls embedded banners, timestamps, and key hints into a structured metadata.json for auditing. |
| 12. Dangerous call scan | `detect_dangerous_calls` | Looks for networking and OS interaction primitives and records contextual lines for manual review. |
| 13. Helper/module lifting | `lift_helper_tables_to_modules` | Classifies helper tables and writes standalone Lua modules for string, bit, or VM operations. |
| 14. Opcode & VM reporting | `generate_upcode_table / opcode_semantics_guesses` | Aggregates lifted VM IR into opcode tables, semantic guesses, and Markdown/JSON artefacts for mapping work. |
| 15. Quality gate evaluation | `evaluate_deobfuscation_checklist / evaluate_quality_gate` | Scores the reconstructed output, enforces completeness thresholds, and confirms parity harness coverage before a run is marked successful. |

Each section below expands on the inputs, outputs, and mitigation strategies for the corresponding stage.

## 1. Fragment discovery

**Function:** `extract_fragments`

**Purpose:** Scans Lua sources for quoted and bracketed fragments while preserving source offsets for downstream reconstruction.

**Inputs**
- Lua payload path

**Outputs**
- Ordered fragment entries with offsets and literal kinds

**Failure modes**
- Source file is missing or unreadable
- Malformed long-bracket delimiters prevent detection

**Recommended remedies**
- Verify the input path and encoding; rerun with a fresh dump of the payload
- Inspect surrounding text to fix bracket depth or fall back to runtime capture of constructed strings

**Runtime-only guidance**
- If no static fragments are discovered, the payload likely assembles data at runtime—capture output via `run_probe_harness` or sandbox tracing before re-running the pipeline.

## 2. Literal decoding

**Function:** `_iter_decoded_fragments / lu_unescape`

**Purpose:** Normalises escape sequences, canonicalising Lua short-string bodies into decoded text for reconstruction.

**Inputs**
- Fragment list

**Outputs**
- Decoded fragment/literal pairs

**Failure modes**
- Unsupported escape sequences or malformed numeric escapes
- Fragments remain encrypted or high-entropy after decoding

**Recommended remedies**
- Update `lu_unescape` support or patch offending fragments before retrying
- Run PRGA candidates or parity harnesses with the session key to obtain plaintext

**Runtime-only guidance**
- High-entropy outputs suggest runtime transforms; prioritise affected fragments with `entropy_detector` and feed them to `run_probe_harness` using the provided key.

## 3. Escape verification

**Function:** `_verify_decoded_string_roundtrip`

**Purpose:** Ensures decoded literals survive a canonicalise → unescape → escape round-trip so no bytes are lost during reconstruction.

**Inputs**
- Decoded fragment pairs

**Outputs**
- Verification report with mismatched indices (if any)

**Failure modes**
- Escape sequences that collapse to different literals after normalisation

**Recommended remedies**
- Inspect the reported fragment offsets and adjust canonicalisation hints before continuing

**Runtime-only guidance**
- When round-trip verification fails only for runtime-generated data, skip static rewriting for those fragments and prefer sandbox extraction.

## 4. Bracket normalisation

**Function:** `_normalize_long_bracket_literals`

**Purpose:** Aligns Lua long-bracket delimiters to a canonical depth while tracking nesting statistics for audits.

**Inputs**
- Concatenated decoded text

**Outputs**
- Bracket-normalised text
- Delimiter depth statistics

**Failure modes**
- Mismatched bracket depth that cannot be normalised

**Recommended remedies**
- Review the reported delimiter span and repair the fragment ordering before re-running

**Runtime-only guidance**
- Runtime builders occasionally emit long brackets on the fly; confirm static reconstruction order with `cluster_fragments_by_similarity` before rewriting.

## 5. Whitespace canonicalisation

**Function:** `_normalize_whitespace`

**Purpose:** Collapses inconsistent indentation and spacing while preserving semantic boundaries for subsequent tooling.

**Inputs**
- Bracket-normalised text

**Outputs**
- Whitespace-normalised Lua text

**Failure modes**
- Irrecoverable control characters in fragments

**Recommended remedies**
- Strip or replace invalid bytes using the fragment offsets and rerun the pass

**Runtime-only guidance**
- If control characters stem from runtime buffers, prefer executing the parity harness to capture clean output before normalisation.

## 6. Numeric literal mapping

**Function:** `_replace_numeric_literals`

**Purpose:** Converts hexadecimal/binary numerics into decimal for readability and records a reversible mapping file.

**Inputs**
- Whitespace-normalised text

**Outputs**
- Canonical text with decimal numerics
- numeric_map.json mapping

**Failure modes**
- Non-standard numeric forms that collide after normalisation

**Recommended remedies**
- Review the generated numeric map and restore conflicting literals selectively

**Runtime-only guidance**
- If numerics are computed at runtime, rely on the snapshot/resume harness to capture concrete values before applying static replacements.

## 7. Boundary diffing

**Function:** `_compute_boundary_report / _summarise_boundary_diff`

**Purpose:** Compares reconstructed fragment boundaries against originals to ensure ordering and offsets remain stable.

**Inputs**
- Decoded fragment pairs
- Reconstructed text

**Outputs**
- Boundary diff report
- boundaries.json artifact

**Failure modes**
- Fragments reordered or collapsed during reconstruction

**Recommended remedies**
- Use the recorded mismatched offsets to repair fragment sequencing or force manual overrides

**Runtime-only guidance**
- A high mismatch rate usually indicates runtime-only concatenation; switch to `parity_test` or the review UI to capture the executed order.

## 8. Bytecode detection

**Function:** `detect_embedded_bytecode`

**Purpose:** Scans decoded fragments for Lua bytecode signatures and emits disassembly reports for embedded chunks.

**Inputs**
- Reconstructed text
- Fragment list

**Outputs**
- Per-chunk bytecode reports
- disassembly artefacts

**Failure modes**
- Compressed or encrypted bytecode segments remain undecoded

**Recommended remedies**
- Run compression detectors or PRGA candidates to obtain raw bytecode before re-running detection

**Runtime-only guidance**
- If bytecode only materialises during execution, instrument the sandbox runner to dump the buffer prior to invoking the detector.

## 9. Obfuscator fingerprinting

**Function:** `fingerprint_obfuscation_patterns`

**Purpose:** Records stable pattern fingerprints for Luraph v14 payloads so subsequent runs can short-circuit analysis.

**Inputs**
- Reconstructed text
- Header metadata

**Outputs**
- fingerprints.json fingerprint cache

**Failure modes**
- Version banner missing or outside the v14 family
- Text cannot be fingerprinted because reconstruction failed

**Recommended remedies**
- Repair header metadata via `detect_luraph_header_from_text` or supply version hints manually
- Re-run the static rebuild or capture runtime text before fingerprinting

**Runtime-only guidance**
- Fingerprints accelerate later runs—commit them only after verifying the payload uses the supplied session key.

## 10. Function boundary export

**Function:** `split_functions_from_payload`

**Purpose:** Splits the reconstructed payload into per-function files with metadata for manual review.

**Inputs**
- Reconstructed Lua path

**Outputs**
- Function snippets
- boundary metadata

**Failure modes**
- Unbalanced `function`/`end` pairs impede splitting

**Recommended remedies**
- Inspect the preview snippet in the metadata and correct syntax before rerunning the splitter

**Runtime-only guidance**
- If the payload defines functions through runtime loaders, capture the executed module via the sandbox then rerun the splitter on the emitted text.

## 11. Metadata & provenance extraction

**Function:** `extract_metadata_provenance`

**Purpose:** Pulls embedded banners, timestamps, and key hints into a structured metadata.json for auditing.

**Inputs**
- Reconstructed Lua text

**Outputs**
- metadata.json with provenance signals

**Failure modes**
- No textual markers survive obfuscation

**Recommended remedies**
- Re-run detection on alternate fragments or enable sandbox logging to capture runtime banners

**Runtime-only guidance**
- Runtime loaders may print banners late; hook the sandbox console output and merge the logs into the metadata report.

## 12. Dangerous call scan

**Function:** `detect_dangerous_calls`

**Purpose:** Looks for networking and OS interaction primitives and records contextual lines for manual review.

**Inputs**
- Reconstructed Lua path

**Outputs**
- dangerous_calls.txt report
- Structured findings

**Failure modes**
- Runtime-only wrappers hide the dangerous call tokens

**Recommended remedies**
- Extend the pattern list or capture executed code via the sandbox before re-running the scan

**Runtime-only guidance**
- If the payload constructs request helpers dynamically, execute the sandbox parity harness to dump the generated source and feed it into the scanner.

## 13. Helper/module lifting

**Function:** `lift_helper_tables_to_modules`

**Purpose:** Classifies helper tables and writes standalone Lua modules for string, bit, or VM operations.

**Inputs**
- Reconstructed Lua text
- Optional luaparser AST

**Outputs**
- Generated helper modules
- classification report

**Failure modes**
- Helper tables exceed heuristic thresholds or use dynamic keys

**Recommended remedies**
- Fallback to text-mode lifting or tune classification thresholds before retrying

**Runtime-only guidance**
- If helper tables are populated dynamically, capture the table via the sandbox, serialise it, and feed the dump into the lifter.

## 14. Opcode & VM reporting

**Function:** `generate_upcode_table / opcode_semantics_guesses`

**Purpose:** Aggregates lifted VM IR into opcode tables, semantic guesses, and Markdown/JSON artefacts for mapping work.

**Inputs**
- Lifted VM IR
- Helper/opcode metadata

**Outputs**
- upcodes.json
- upcodes.md
- opcode_guesses.json

**Failure modes**
- Insufficient IR due to earlier decode failures

**Recommended remedies**
- Re-run VM lifting after addressing earlier pipeline errors or regenerate IR from the sandbox trace

**Runtime-only guidance**
- When IR cannot be lifted statically, use `simulate_vm` with sandbox inputs to harvest executed opcode traces before generating documentation.

## 15. Quality gate evaluation

**Function:** `evaluate_deobfuscation_checklist / evaluate_quality_gate`

**Purpose:** Scores the reconstructed output, enforces completeness thresholds, and confirms parity harness coverage before a run is marked successful.

**Inputs**
- Checklist emitted by `evaluate_deobfuscation_checklist`
- Configured gate options (threshold, parity requirements)

**Outputs**
- Quality gate summary and failure reasons
- Optional mapping.lock updates when rename confidence is high

**Failure modes**
- Checklist unavailable because reconstruction did not produce output
- Completeness score below the configured threshold
- Required parity tests missing or failing

**Recommended remedies**
- Re-run the pipeline with `--quality-allow-parity-failures` when sandbox parity data is unavailable
- Inspect earlier pipeline stages or crash reports to restore completeness score inputs

**Runtime-only guidance**
- Dynamic transforms that only complete under sandbox execution may leave parity totals at zero; either provide runtime traces or disable the parity requirement for the current session.

## Handling runtime-only transforms

When a stage reports high entropy, missing fragments, or boundary mismatches, prefer executing ``run_probe_harness`` with the session key, capturing sandbox traces via ``parity_test`` or ``round_trip_test``, and resuming the snapshot-enabled search to gather concrete runtime artefacts before re-running the static pipeline.

The manifest (``run_manifest.json``) records which stages ran and which transforms succeeded so pipeline reruns remain reproducible.
