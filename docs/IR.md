# Virtual Machine IR JSON Format

This document records the lightweight intermediate representation generated by
`src.vm.lifter.Lifter`.  The goal is to provide a predictable, version-agnostic
structure that downstream tooling can inspect or transform without having to
re-run the disassembler.

## Top-Level Layout

The serialized IR is a JSON object with two keys:

* `metadata` – dictionary describing program level information such as
  `instruction_count`, `block_count`, and optional provenance hints supplied by
  callers.
* `blocks` – ordered list of basic block objects.  Blocks are emitted in
  traversal order and each entry describes a straight-line sequence of lifted
  operations.

```json
{
  "metadata": {
    "instruction_count": 42,
    "block_count": 4,
    "source": "tests/samples/Obfuscated3.lua"
  },
  "blocks": [
    {
      "id": "block_0",
      "start_index": 0,
      "end_index": 4,
      "raw_offsets": [0, 1, 2, 3, 4],
      "fallthrough": "block_1",
      "jump": null,
      "ops": [
        {
          "index": 0,
          "raw": 4198400,
          "mnemonic": "MOVE",
          "operands": [
            {"field": "a", "kind": "reg", "value": 1},
            {"field": "b", "kind": "operand", "value": 3},
            {"field": "c", "kind": "operand", "value": 0}
          ]
        }
      ]
    }
  ]
}
```

## Basic Block Schema

Each block object contains:

| Field | Description |
| --- | --- |
| `id` | Stable identifier (e.g. `block_7`). |
| `start_index` | Instruction index of the first operation in the block. |
| `end_index` | Instruction index of the final operation in the block. |
| `raw_offsets` | List of original disassembler indices captured for traceability. |
| `fallthrough` | ID of the block executed next when control continues naturally, or `null` if unknown. |
| `jump` | ID of the branch target for terminating instructions, or `null` if none is known. |
| `ops` | Ordered list of lifted operations within the block. |

## Operation Schema

Each entry in `ops` is an IR operation described by:

* `index` – original instruction index within the disassembly listing.
* `raw` – raw integer word corresponding to the instruction.
* `mnemonic` – canonical mnemonic resolved by the opcode map, or a generated
  placeholder such as `OP_0A` when no mapping exists.
* `operands` – array of operand objects, each with:
  * `field` – source field name from the disassembler (`a`, `b`, `c`).
  * `kind` – semantic hint such as `reg`, `operand`, or caller supplied values.
  * `value` – integer operand value as lifted from the disassembly.

## Extensibility

The schema intentionally leaves room for additional metadata.  Consumers should
ignore unknown keys so that future lifter revisions can attach annotations (for
example, constant decoding hints or inferred control-flow relationships) without
breaking older tooling.

## Helper Utilities

`src.vm.ir_utils` provides convenience helpers for working with IR payloads:

* `pretty_print_ir` renders human-friendly listings that include block IDs,
  mnemonics, and operand annotations.  This is useful when triaging decoded
  payloads without opening the raw JSON.
* `compute_cfg` derives successor and predecessor maps from the block list,
  normalising the `fallthrough`, `jump`, and `successors` fields emitted by the
  lifter.  The resulting adjacency tables make it trivial to feed graph tools
  or verify reconstructions.
* `collapse_trivial_blocks` simplifies structured IR by removing empty bridge
  blocks that merely redirect to another block.  This helps downstream
  structured control-flow reconstruction produce smaller, easier-to-read
  graphs.

All helpers operate on the in-memory dataclasses defined in `src.vm.lifter` and
avoid mutating the original IR program.

## Example: Luraph v14.4.2 Structured IR

The snippet below illustrates a real-world block extracted from a Luraph
v14.4.2 sample.  The block loads a constant, performs an arithmetic operation,
and conditionally jumps:

```json
{
  "id": "block_12",
  "start_index": 87,
  "end_index": 90,
  "raw_offsets": [87, 88, 89, 90],
  "fallthrough": "block_13",
  "jump": "block_27",
  "ops": [
    {"index": 87, "raw": 31537378, "mnemonic": "LOADK", "operands": [
      {"field": "a", "kind": "reg", "value": 5},
      {"field": "bx", "kind": "const", "value": 12, "resolved": "magic_key"}
    ]},
    {"index": 88, "raw": 120588325, "mnemonic": "ADD", "operands": [
      {"field": "a", "kind": "reg", "value": 6},
      {"field": "b", "kind": "reg", "value": 5},
      {"field": "c", "kind": "reg", "value": 7}
    ]},
    {"index": 90, "raw": 146997249, "mnemonic": "EQ", "operands": [
      {"field": "a", "kind": "reg", "value": 6},
      {"field": "b", "kind": "const", "value": 0, "resolved": 0},
      {"field": "c", "kind": "reg", "value": 8}
    ], "metadata": {"condition": "if_equal"}}
  ]
}
```

When `collapse_trivial_blocks` is applied to the surrounding IR, bridging blocks
that solely point at `block_12` are pruned, leaving a minimal CFG that feeds
directly into control-flow reconstruction.

