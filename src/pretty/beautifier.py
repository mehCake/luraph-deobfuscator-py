"""Pipeline helpers that combine formatting, reflow, and constant inlining.

The beautifier orchestrates a deterministic sequence of presentation steps so
analysts receive a single entry point when tidying lifted VM output:

1.  ``inline_constants`` is used to materialise friendly literals inside the
    IR before rendering pseudo-Lua text via :func:`emit_inline`.
2.  The emitted text flows through :func:`src.pretty.prettify.format_pseudo_lua`
    so indentation, comment headers, and wrapping rules are applied.
3.  Finally :func:`src.pretty.reflow_controlflow.reflow_pseudo_lua` removes
    redundant ``goto`` statements and normalises dispatcher sections.

The resulting string is written to ``out/deobfuscated_pretty.lua`` (unless the
caller specifies a different output path).  Optional intermediate artefacts are
available for debugging, but the pipeline never overwrites user-authored files
unless the caller explicitly passes ``overwrite=True`` or ``--overwrite`` when
using the CLI.
"""

from __future__ import annotations

import argparse
import json
import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Mapping, MutableMapping, Optional, Sequence

from ..vm.inline_emitter import emit_inline
from ..vm.lifter import IRProgram
from .inline_constants import (
    DEFAULT_MAX_NUMERIC_ABS,
    DEFAULT_MAX_STRING_LENGTH,
    DEFAULT_MAX_USAGE,
    InlineSummary,
    inline_constants_payload,
)
from .prettify import Provenance, format_pseudo_lua
from .reflow_controlflow import ReflowStats, reflow_pseudo_lua

LOGGER = logging.getLogger(__name__)

DEFAULT_OUTPUT = Path("out/deobfuscated_pretty.lua")
DEFAULT_INTERMEDIATE_DIR = Path("out/beautifier")


@dataclass
class BeautifyResult:
    """Output artefacts generated by :func:`beautify`."""

    program: IRProgram
    inline_summary: InlineSummary
    reflow_stats: ReflowStats
    formatted_path: Optional[Path]
    reflowed_path: Optional[Path]
    final_path: Path


def beautify(
    ir_path: Path,
    constants_path: Path,
    *,
    output_path: Path = DEFAULT_OUTPUT,
    intermediate_dir: Optional[Path] = DEFAULT_INTERMEDIATE_DIR,
    overwrite: bool = False,
    indent_width: int = 4,
    max_column: int = 120,
    version_hint: Optional[str] = None,
    max_usage: int = DEFAULT_MAX_USAGE,
    max_string_length: int = DEFAULT_MAX_STRING_LENGTH,
    max_numeric_abs: float = DEFAULT_MAX_NUMERIC_ABS,
    provenance_profile: Optional[Mapping[str, Any]] = None,
    provenance_label: Optional[str] = None,
) -> BeautifyResult:
    """Run the formatting pipeline and persist the beautified pseudo-Lua.

    Parameters
    ----------
    ir_path:
        Path to a lifted IR JSON payload (e.g., produced by the lifter).
    constants_path:
        Path to a decoded constant pool (JSON array or mapping with a
        ``"constants"`` key).
    output_path:
        Destination file for the final prettified pseudo-Lua listing.
    intermediate_dir:
        Optional directory that receives intermediate text snapshots
        (``formatted.lua`` and ``reflowed.lua``).  When ``None`` intermediates
        are kept in memory only.
    overwrite:
        When ``False`` (the default) existing ``output_path`` files cause a
        :class:`FileExistsError` so user edits are never clobbered.
    indent_width / max_column:
        Formatting preferences forwarded to :func:`format_pseudo_lua`.
    version_hint:
        Optional hint passed to :func:`reflow_pseudo_lua` so version specific
        heuristics can activate (e.g., ``"v14.4.2"`` dispatcher ordering).
    max_usage / max_string_length / max_numeric_abs:
        Thresholds forwarded to :func:`inline_constants_payload`.
    provenance_profile / provenance_label:
        When supplied, a ``-- PROVENANCE`` header describing the transform
        configuration is injected at the top of the formatted output.
    """

    payload = _load_json(ir_path)
    constants = _load_constants(constants_path)

    program, inline_summary = inline_constants_payload(
        payload,
        constants,
        max_usage=max_usage,
        max_string_length=max_string_length,
        max_numeric_abs=max_numeric_abs,
    )

    raw_source = emit_inline(program)

    provenance = None
    if provenance_profile is not None:
        provenance = Provenance.from_profile(provenance_profile, label=provenance_label)

    formatted_text = format_pseudo_lua(
        raw_source,
        indent_width=indent_width,
        max_column=max_column,
        provenance=provenance,
    )

    formatted_path: Optional[Path] = None
    reflowed_path: Optional[Path] = None

    if intermediate_dir is not None:
        intermediate_dir.mkdir(parents=True, exist_ok=True)
        formatted_path = intermediate_dir / "formatted.lua"
        formatted_path.write_text(formatted_text, encoding="utf-8")
        LOGGER.debug("Wrote formatted intermediate to %s", formatted_path)

    reflowed_text, reflow_stats = reflow_pseudo_lua(formatted_text, version_hint=version_hint)

    if intermediate_dir is not None:
        reflowed_path = intermediate_dir / "reflowed.lua"
        reflowed_path.write_text(reflowed_text, encoding="utf-8")
        LOGGER.debug("Wrote reflowed intermediate to %s", reflowed_path)

    if output_path.exists() and not overwrite:
        raise FileExistsError(
            f"Refusing to overwrite existing beautified output at {output_path}. "
            "Pass overwrite=True or --overwrite to replace it."
        )

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(reflowed_text, encoding="utf-8")
    LOGGER.info("Wrote beautified pseudo-Lua to %s", output_path)

    return BeautifyResult(
        program=program,
        inline_summary=inline_summary,
        reflow_stats=reflow_stats,
        formatted_path=formatted_path,
        reflowed_path=reflowed_path,
        final_path=output_path,
    )


def _load_json(path: Path) -> MutableMapping[str, Any]:
    with path.open("r", encoding="utf-8") as handle:
        data = json.load(handle)
    if not isinstance(data, MutableMapping):
        raise ValueError(f"IR payload at {path} must be a JSON object")
    return data


def _load_constants(path: Path) -> Sequence[Any]:
    with path.open("r", encoding="utf-8") as handle:
        data = json.load(handle)
    if isinstance(data, Mapping):
        payload = data.get("constants")
        if payload is None:
            raise ValueError("mapping constant files must contain a 'constants' key")
        data = payload
    if not isinstance(data, list):
        raise ValueError("constant pool must be a list")
    return data


def _load_profile(path: Optional[Path]) -> Optional[Mapping[str, Any]]:
    if path is None:
        return None
    with path.open("r", encoding="utf-8") as handle:
        data = json.load(handle)
    if not isinstance(data, Mapping):
        raise ValueError("transform profile must be a JSON object")
    return data


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Beautify pseudo-Lua output using prettify, reflow, and inline constants")
    parser.add_argument("ir", type=Path, help="Path to lifted IR JSON payload")
    parser.add_argument("constants", type=Path, help="Path to decoded constant pool (JSON list)")
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help="Destination for the beautified pseudo-Lua (default: out/deobfuscated_pretty.lua)",
    )
    parser.add_argument(
        "--intermediate-dir",
        type=Path,
        default=DEFAULT_INTERMEDIATE_DIR,
        help="Directory for intermediate artefacts (default: out/beautifier)",
    )
    parser.add_argument("--overwrite", action="store_true", help="Replace existing output if present")
    parser.add_argument("--indent-width", type=int, default=4, help="Indent width for formatted output")
    parser.add_argument("--max-column", type=int, default=120, help="Maximum column width for formatted output")
    parser.add_argument("--version-hint", type=str, default=None, help="Version hint forwarded to reflow heuristics")
    parser.add_argument("--max-usage", type=int, default=DEFAULT_MAX_USAGE, help="Maximum usages before constants stay indirect")
    parser.add_argument(
        "--max-string-length",
        type=int,
        default=DEFAULT_MAX_STRING_LENGTH,
        help="Longest string literal eligible for inlining",
    )
    parser.add_argument(
        "--max-numeric-abs",
        type=float,
        default=DEFAULT_MAX_NUMERIC_ABS,
        help="Inline numeric constants whose absolute value is within this bound",
    )
    parser.add_argument(
        "--profile",
        type=Path,
        default=None,
        help="Optional JSON transform profile injected as a provenance header",
    )
    parser.add_argument(
        "--profile-label",
        type=str,
        default=None,
        help="Optional label added to the provenance summary",
    )

    args = parser.parse_args(argv)

    provenance_profile = _load_profile(args.profile) if args.profile else None

    result = beautify(
        args.ir,
        args.constants,
        output_path=args.output,
        intermediate_dir=args.intermediate_dir,
        overwrite=args.overwrite,
        indent_width=args.indent_width,
        max_column=args.max_column,
        version_hint=args.version_hint,
        max_usage=args.max_usage,
        max_string_length=args.max_string_length,
        max_numeric_abs=args.max_numeric_abs,
        provenance_profile=provenance_profile,
        provenance_label=args.profile_label,
    )

    LOGGER.info("Inline summary: %s", result.inline_summary.as_dict())
    LOGGER.info("Reflow stats: %s", result.reflow_stats.as_dict())
    LOGGER.info("Beautified output written to %s", result.final_path)
    return 0


__all__ = ["BeautifyResult", "beautify", "main"]


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())
