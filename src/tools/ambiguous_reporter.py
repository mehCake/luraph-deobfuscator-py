"""Generate an ambiguity report for opcode mappings and structured IR.

The reporter consumes the static artefacts produced by the collection and
lifting pipeline – namely ``pipeline_candidates.json``,
``opcode_proposals.json`` and the structured control-flow JSON files emitted by
``src.vm.reconstruct_controlflow``.  It highlights areas where the automatic
analysis assigned low confidence or conflicting interpretations and suggests
follow-up experiments for analysts (e.g. recording a runtime trace).

No untrusted code is executed.  The module only inspects JSON/Markdown data
already generated by other tooling and never persists session keys.
"""

from __future__ import annotations

import argparse
import json
import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Mapping, MutableMapping, Optional, Sequence, Tuple

LOGGER = logging.getLogger(__name__)

LOW_CONFIDENCE_THRESHOLD = 0.75
ALT_CONFIDENCE_THRESHOLD = 0.55
ALT_CONFIDENCE_GAP = 0.2


def _load_json(path: Path) -> Mapping[str, object]:
    try:
        text = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        LOGGER.debug("Ambiguity artefact %s not found", path)
        return {}
    except OSError as exc:  # pragma: no cover - filesystem edge case
        LOGGER.warning("Failed to read %s: %s", path, exc)
        return {}

    try:
        payload = json.loads(text)
    except json.JSONDecodeError as exc:
        LOGGER.warning("Failed to parse JSON from %s: %s", path, exc)
        return {}

    if isinstance(payload, Mapping):
        return payload
    LOGGER.warning("Expected JSON object in %s; got %s", path, type(payload).__name__)
    return {}


def _to_int(value: object) -> Optional[int]:
    if isinstance(value, int):
        return value
    try:
        return int(value)  # type: ignore[arg-type]
    except (TypeError, ValueError):
        try:
            return int(str(value), 0)
        except (TypeError, ValueError):
            return None


def _normalise_sequence(values: Iterable[object]) -> Tuple[str, ...]:
    seen = []
    for item in values:
        text = str(item)
        if text and text not in seen:
            seen.append(text)
    return tuple(seen)


@dataclass(frozen=True)
class AmbiguousOpcode:
    opcode: int
    mnemonic: Optional[str]
    confidence: float
    reasons: Tuple[str, ...]
    suggestions: Tuple[str, ...]

    def summary(self) -> str:
        mnemonic = self.mnemonic or "<unknown>"
        joined = "; ".join(self.reasons)
        return f"Opcode 0x{self.opcode:02X} ({mnemonic}): {joined}"


@dataclass(frozen=True)
class AmbiguousIRNode:
    location: str
    issues: Tuple[str, ...]
    suggestions: Tuple[str, ...]

    def summary(self) -> str:
        joined = ", ".join(self.issues)
        return f"IR {self.location}: {joined}"


@dataclass(frozen=True)
class AmbiguousReport:
    opcodes: Tuple[AmbiguousOpcode, ...]
    ir_nodes: Tuple[AmbiguousIRNode, ...]

    def as_dict(self) -> Mapping[str, object]:
        return {
            "opcodes": [
                {
                    "opcode": item.opcode,
                    "mnemonic": item.mnemonic,
                    "confidence": item.confidence,
                    "reasons": list(item.reasons),
                    "suggestions": list(item.suggestions),
                }
                for item in self.opcodes
            ],
            "ir_nodes": [
                {
                    "location": item.location,
                    "issues": list(item.issues),
                    "suggestions": list(item.suggestions),
                }
                for item in self.ir_nodes
            ],
            "summary": list(self.summary()),
        }

    def summary(self) -> Tuple[str, ...]:
        notes = [item.summary() for item in self.opcodes]
        notes.extend(item.summary() for item in self.ir_nodes)
        return tuple(notes)

    def render_markdown(self) -> str:
        lines = ["# Ambiguity Report", ""]

        lines.append("## Opcodes Requiring Dynamic Verification")
        if not self.opcodes:
            lines.append("* No ambiguous opcode mappings detected.")
        else:
            for entry in self.opcodes:
                mnemonic = entry.mnemonic or "<unknown>"
                lines.append(
                    f"* `0x{entry.opcode:02X}` → `{mnemonic}` (confidence {entry.confidence:.2f})"
                )
                lines.append("  - Reasons: " + "; ".join(entry.reasons))
                for suggestion in entry.suggestions:
                    lines.append(f"  - Suggestion: {suggestion}")
        lines.append("")

        lines.append("## IR Regions With Uncertain Structure")
        if not self.ir_nodes:
            lines.append("* No ambiguous IR nodes detected.")
        else:
            for entry in self.ir_nodes:
                lines.append(f"* `{entry.location}` — issues: {', '.join(entry.issues)}")
                for suggestion in entry.suggestions:
                    lines.append(f"  - Suggestion: {suggestion}")
        lines.append("")

        if self.summary():
            lines.append("## Summary")
            for note in self.summary():
                lines.append(f"* {note}")
            lines.append("")

        return "\n".join(lines)


def _collect_opcode_handlers(payload: Mapping[str, object]) -> Mapping[int, Tuple[str, ...]]:
    handlers: MutableMapping[int, Tuple[str, ...]] = {}
    raw = payload.get("opcode_handlers")
    if isinstance(raw, Mapping):
        for key, value in raw.items():
            opcode = _to_int(key)
            if opcode is None:
                continue
            if isinstance(value, Sequence):
                handlers[opcode] = _normalise_sequence(value)
            else:
                handlers[opcode] = _normalise_sequence((value,))
    return handlers


def _opcode_suggestions(opcode: int, mnemonic: Optional[str], handlers: Sequence[str]) -> Tuple[str, ...]:
    hints = []
    if handlers:
        listed = ", ".join(handlers[:2])
        hints.append(
            f"Record a focused trace for handler(s) {listed} with `python -m src.tools.trace_recorder` "
            "to observe register and stack updates."
        )
    hints.append(
        "Replay captured traces with `python -m src.tools.replay_trace` and compare results using "
        "candidate opcode maps to confirm the semantics."
    )
    label = mnemonic or "the opcode"
    hints.append(
        f"Construct a sandbox snippet that executes opcode 0x{opcode:02X} ({label}) with controlled inputs and "
        "verify the resulting VM state."
    )
    return tuple(dict.fromkeys(hints))


def _analyse_opcode_proposals(
    pipeline_payload: Mapping[str, object],
    proposals_payload: Mapping[str, object],
) -> Tuple[AmbiguousOpcode, ...]:
    candidates_raw = proposals_payload.get("candidates")
    if not isinstance(candidates_raw, Sequence):
        return ()

    options: MutableMapping[int, list[Mapping[str, object]]] = {}
    for candidate in candidates_raw:
        if not isinstance(candidate, Mapping):
            continue
        cand_conf = float(candidate.get("confidence", 0.0))
        mapping = candidate.get("mapping")
        selections = candidate.get("selections")
        if not isinstance(mapping, Mapping):
            mapping = {}
        if not isinstance(selections, Mapping):
            selections = {}

        for key, entry in selections.items():
            opcode = _to_int(key)
            if opcode is None or not isinstance(entry, Mapping):
                continue
            mnemonic = entry.get("mnemonic") or mapping.get(str(opcode)) or mapping.get(opcode)
            option = {
                "mnemonic": str(mnemonic) if mnemonic else None,
                "confidence": float(entry.get("confidence", cand_conf)),
                "candidate_confidence": cand_conf,
                "handlers": entry.get("handlers", ()),
                "reasons": entry.get("reasons", ()),
            }
            options.setdefault(opcode, []).append(option)

        for key, mnemonic in mapping.items():
            opcode = _to_int(key)
            if opcode is None:
                continue
            option = {
                "mnemonic": str(mnemonic) if mnemonic else None,
                "confidence": cand_conf,
                "candidate_confidence": cand_conf,
                "handlers": (),
                "reasons": (),
            }
            options.setdefault(opcode, []).append(option)

    if not options:
        return ()

    handler_lookup = _collect_opcode_handlers(pipeline_payload)
    ambiguous: list[AmbiguousOpcode] = []

    for opcode, entries in options.items():
        entries.sort(
            key=lambda item: (float(item.get("confidence", 0.0)), float(item.get("candidate_confidence", 0.0))),
            reverse=True,
        )
        best = entries[0]
        mnemonic = best.get("mnemonic")
        best_conf = float(best.get("confidence", 0.0))
        best_candidate_conf = float(best.get("candidate_confidence", 0.0))

        reasons = []
        if best_conf < LOW_CONFIDENCE_THRESHOLD:
            reasons.append(f"top mnemonic confidence {best_conf:.2f} below {LOW_CONFIDENCE_THRESHOLD:.2f}")
        if best_candidate_conf < LOW_CONFIDENCE_THRESHOLD:
            reasons.append(
                f"overall map confidence {best_candidate_conf:.2f} suggests handler disagreement"
            )

        alternate_reason_added = False
        if len(entries) > 1:
            alt = entries[1]
            alt_conf = float(alt.get("confidence", 0.0))
            alt_mnemonic = alt.get("mnemonic")
            if (
                alt_mnemonic
                and alt_mnemonic != mnemonic
                and alt_conf >= ALT_CONFIDENCE_THRESHOLD
                and best_conf - alt_conf <= ALT_CONFIDENCE_GAP
            ):
                reasons.append(
                    f"alternate mnemonic {alt_mnemonic} scores {alt_conf:.2f} (close to {best_conf:.2f})"
                )
                alternate_reason_added = True

        if not reasons and not alternate_reason_added:
            continue

        handlers = handler_lookup.get(opcode, ())
        handler_names = handlers if handlers else _normalise_sequence(best.get("handlers", ()))
        suggestions = _opcode_suggestions(opcode, mnemonic, handler_names)
        ambiguous.append(
            AmbiguousOpcode(
                opcode=opcode,
                mnemonic=mnemonic if isinstance(mnemonic, str) else None,
                confidence=best_conf,
                reasons=tuple(reasons),
                suggestions=suggestions,
            )
        )

    ambiguous.sort(key=lambda item: item.opcode)
    return tuple(ambiguous)


_ISSUE_SUGGESTIONS = {
    "missing_join": "Trace the conditional branch and inspect the join block with `src.tools.trace_recorder` to confirm the post-branch target.",
    "missing_else": "Exercise the branch with alternative inputs in a sandbox to see whether an else block executes.",
    "empty_then": "Record runtime state when the condition succeeds to confirm whether the then-block performs side effects.",
    "missing_exit": "Run the loop with bounded iterations and inspect program counter deltas to locate the exit handler.",
    "empty_body": "Replay traces with instrumentation to validate whether the loop body truly performs no operations.",
}


def _walk_ast(node: Mapping[str, object], prefix: str, results: list[AmbiguousIRNode]) -> None:
    metadata = node.get("metadata")
    issues: Tuple[str, ...] = ()
    if isinstance(metadata, Mapping):
        raw = metadata.get("uncertain")
        if isinstance(raw, Sequence):
            filtered = [str(entry) for entry in raw if entry]
            issues = tuple(filtered)
    if issues:
        suggestions = []
        for issue in issues:
            suggestion = _ISSUE_SUGGESTIONS.get(issue)
            if suggestion:
                suggestions.append(suggestion)
        if not suggestions:
            suggestions.append(
                "Collect a control-flow trace in the sandbox and compare with reconstructed IR to resolve the ambiguity."
            )
        results.append(
            AmbiguousIRNode(
                location=prefix,
                issues=issues,
                suggestions=tuple(dict.fromkeys(suggestions)),
            )
        )

    node_type = str(node.get("type", ""))
    if node_type == "sequence":
        children = node.get("nodes")
        if isinstance(children, Sequence):
            for index, child in enumerate(children):
                if isinstance(child, Mapping):
                    _walk_ast(child, f"{prefix}/seq[{index}]", results)
    elif node_type == "if":
        for label in ("condition", "then", "else"):
            child = node.get(label)
            if isinstance(child, Mapping):
                _walk_ast(child, f"{prefix}/if.{label}", results)
    elif node_type == "while":
        for label in ("header", "body"):
            child = node.get(label)
            if isinstance(child, Mapping):
                _walk_ast(child, f"{prefix}/while.{label}", results)
    elif node_type == "block":
        block_id = node.get("id")
        if block_id is not None:
            prefix = f"{prefix}/block:{block_id}"


def _analyse_structured_dir(structured_dir: Optional[Path]) -> Tuple[AmbiguousIRNode, ...]:
    if structured_dir is None or not structured_dir.exists():
        return ()

    results: list[AmbiguousIRNode] = []
    for json_path in sorted(structured_dir.glob("*.json")):
        payload = _load_json(json_path)
        body = payload.get("body")
        if not isinstance(body, Mapping):
            continue
        base = f"{json_path.name}"
        _walk_ast(body, base, results)
    results.sort(key=lambda item: item.location)
    return tuple(results)


def build_ambiguous_report(
    pipeline_path: Path,
    proposals_path: Path,
    *,
    structured_dir: Optional[Path] = None,
) -> AmbiguousReport:
    pipeline_payload = _load_json(pipeline_path)
    if not pipeline_payload:
        raise FileNotFoundError(f"Pipeline report not found: {pipeline_path}")

    proposals_payload = _load_json(proposals_path)
    if not proposals_payload:
        LOGGER.info("Opcode proposals missing or empty; ambiguity report will focus on IR only.")

    opcodes = _analyse_opcode_proposals(pipeline_payload, proposals_payload)
    ir_nodes = _analyse_structured_dir(structured_dir)
    return AmbiguousReport(opcodes=opcodes, ir_nodes=ir_nodes)


def write_markdown(report: AmbiguousReport, destination: Path) -> Path:
    destination.parent.mkdir(parents=True, exist_ok=True)
    destination.write_text(report.render_markdown(), encoding="utf-8")
    LOGGER.info("Wrote ambiguous analysis report to %s", destination)
    return destination


def write_json(report: AmbiguousReport, destination: Path) -> Path:
    destination.parent.mkdir(parents=True, exist_ok=True)
    destination.write_text(json.dumps(report.as_dict(), indent=2) + "\n", encoding="utf-8")
    LOGGER.info("Wrote ambiguous analysis summary to %s", destination)
    return destination


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(description="Generate ambiguity report for opcode/IR analysis")
    parser.add_argument(
        "--pipeline",
        type=Path,
        default=Path("out") / "pipeline_candidates.json",
        help="Path to pipeline_candidates.json",
    )
    parser.add_argument(
        "--proposals",
        type=Path,
        default=Path("out") / "opcode_proposals.json",
        help="Path to opcode_proposals.json",
    )
    parser.add_argument(
        "--structured-dir",
        type=Path,
        default=Path("out") / "structured",
        help="Directory containing structured control-flow JSON artefacts",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("out") / "ambiguous.md",
        help="Destination Markdown file",
    )
    parser.add_argument(
        "--json-output",
        type=Path,
        default=Path("out") / "ambiguous.json",
        help="Destination JSON summary file",
    )
    args = parser.parse_args(argv)

    try:
        report = build_ambiguous_report(
            pipeline_path=args.pipeline,
            proposals_path=args.proposals,
            structured_dir=args.structured_dir,
        )
    except FileNotFoundError as exc:
        LOGGER.error(str(exc))
        return 1

    write_markdown(report, args.output)
    write_json(report, args.json_output)
    for note in report.summary():
        LOGGER.info("Ambiguity: %s", note)
    return 0


__all__ = [
    "AmbiguousOpcode",
    "AmbiguousIRNode",
    "AmbiguousReport",
    "build_ambiguous_report",
    "write_markdown",
    "write_json",
    "main",
]

