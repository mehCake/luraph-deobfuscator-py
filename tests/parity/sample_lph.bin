{
  "decoded_payload_hex": "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f",
  "key_hex": "1f2e3d4c5b",
  "lua_source": "(function()\n  local bit = rawget(_G, \"bit32\")\n  if not bit then\n    local ok, lib = pcall(require, \"bit32\")\n    if ok then\n      bit = lib\n    end\n  end\n  if not bit then\n    local ok, lib = pcall(require, \"bit\")\n    if ok then\n      bit = lib\n    end\n  end\n  assert(bit, \"bit library unavailable\")\n  local band = bit.band\n  local bor = bit.bor\n  local bxor = bit.bxor\n  local rshift = bit.rshift\n  local lshift = bit.lshift\n  local function ror8(value, rotation)\n    rotation = rotation % 8\n    value = band(value, 0xFF)\n    if rotation == 0 then\n      return value\n    end\n    local right = rshift(value, rotation)\n    local left = lshift(value, 8 - rotation)\n    return band(bor(right, left), 0xFF)\n  end\n  local function apply_prga_ref(decoded, key)\n    assert(#key > 0, \"key must be non-empty\")\n    local total = #decoded\n    local key_len = #key\n    local out = {}\n    for idx = 0, total - 1 do\n      local lua_index = idx + 1\n      local key_index = (idx % key_len) + 1\n      local key_byte = key:byte(key_index)\n      local permuted_index = ((idx + key_byte) % total) + 1\n      local input_byte = decoded:byte(permuted_index)\n      local xored = bxor(input_byte, key_byte)\n      local rotation = band(key_byte, 7)\n      local result = ror8(xored, rotation)\n      out[lua_index] = string.char(result)\n    end\n    return table.concat(out)\n  end\n  return { apply_prga_ref = apply_prga_ref }\nend)()"
}